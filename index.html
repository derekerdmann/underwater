<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Underwater Volumes</title>
    <link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
	<script id="fragmentShader" type="x-shader/x-fragment">

			uniform vec3 directionalLightColor;
			uniform vec3 directionalLightDirection;
			
			uniform float surfaceLevel;
			
			varying vec3 vWorldPosition;
			varying vec3 vViewPosition;
			varying vec3 vNormal;
			
			void main( void ) {
				
				vec3 diffuse;
				vec3 specular;
				
				vec3 d = cameraPosition - vWorldPosition;
				float distanceFromCamera = length(d);
				float distanceFromSurface = surfaceLevel- vWorldPosition.y;
				
				
				float depth = distanceFromSurface / 100.0;
				float dist = distanceFromCamera/50.0;
				
				vec3 water = vec3(0,0,1);
				
				vec4 lDirection = viewMatrix * vec4( directionalLightDirection, 0.0 );
				vec3 dirVector = normalize( lDirection.xyz );
				
				float dirDiffuseWeight = max( dot( vNormal, dirVector ), 0.0 );
				
				//determine color
				
				vec3 uDiffuseColor = vec3(0.6,0.6,0.6);
				vec3 uSpecularColor = vec3(0.3,0.3,0.3);
				vec3 ambientLight= vec3(0.01,0.01,0.01);
				float uShininess = 2.0;
				
				
				diffuse = directionalLightColor* uDiffuseColor * dirDiffuseWeight;
					
				vec3 dirHalfVector = normalize( dirVector + vViewPosition );
				float dirDotNormalHalf = max( dot( vNormal, dirHalfVector ), 0.0 );
				float dirSpecularWeight = max( pow( dirDotNormalHalf, uShininess ), 0.0 );
					
				specular = directionalLightColor* uSpecularColor * dirSpecularWeight * dirDiffuseWeight;
				
				vec3 color = ambientLight + diffuse + specular;
				color = color;
				
				gl_FragColor =  vec4(color,1.0);
			}

		</script>

		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec3 vWorldPosition;
			varying vec3 vViewPosition;
			varying vec3 vNormal;
		
			
			void main()
			{
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
				vWorldPosition = worldPosition.xyz;
				vViewPosition = -mvPosition.xyz;
				vNormal = normalize( normalMatrix * normal );
			}

		</script>


	<script src="three.min.js"></script>
	<script src="jquery-2.0.0.min.js"></script>
	<script src="Detector.js"></script>
    <script src="underwater.js"></script>
</body>
</html>
