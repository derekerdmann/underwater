<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Underwater Volumes</title>
    <style>
			body {
				background:#005;
			}
	</style>
	<script src="three.min.js"></script>
	<script type='text/javascript' src='http://code.jquery.com/jquery-1.4.2.js'></script>
	<script src="Detector.js"></script>
</head>
<body>
	<script id="fragmentShader" type="x-shader/x-fragment">

			uniform vec3 directionalLightColor;
			uniform vec3 directionalLightDirection;
			
			varying vec3 vWorldPosition;
			varying vec3 vViewPosition;
			varying vec3 vNormal;
			
			void main( void ) {
				
				
				vec3 diffuse;
				vec3 specular;
				
				vec4 lDirection = viewMatrix * vec4( directionalLightDirection, 0.0 );
				vec3 dirVector = normalize( lDirection.xyz );
				
				float dirDiffuseWeight = max( dot( vNormal, dirVector ), 0.0 );
				
				//determine color
				
				vec3 uDiffuseColor = vec3(0.6,0.6,0.6);
				vec3 uSpecularColor = vec3(0.3,0.3,0.3);
				vec3 ambientLight= vec3(0.01,0.01,0.01);
				float uShininess = 2.0;
				
				
				diffuse = directionalLightColor* uDiffuseColor * dirDiffuseWeight;
					
				vec3 dirHalfVector = normalize( dirVector + vViewPosition );
				float dirDotNormalHalf = max( dot( vNormal, dirHalfVector ), 0.0 );
				float dirSpecularWeight = max( pow( dirDotNormalHalf, uShininess ), 0.0 );
					
				specular = directionalLightColor* uSpecularColor * dirSpecularWeight * dirDiffuseWeight;
					
				
				gl_FragColor =  vec4((ambientLight +diffuse+ specular),1.0);
				
			}

		</script>

		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec3 vWorldPosition;
			varying vec3 vViewPosition;
			varying vec3 vNormal;
		
			
			void main()
			{
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
				vWorldPosition = worldPosition.xyz;
				vViewPosition = -mvPosition.xyz;
				vNormal = normalize( normalMatrix * normal );
			}

		</script>
	<script>
	if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			
			var container;

			var camera, scene, renderer;
			var uniforms, material;
			var sun;
			
			var anim = true;
			
			
			var array;
			var type;
			
			init();
			animate();
		
			function init() {
			
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.001, 1000);
				camera.position.set( 0, 0, 3 );

				scene = new THREE.Scene();
				sun = new THREE.DirectionalLight( 0xffffff);
				sun.position.set(2,2,2);
				scene.add( sun );
				
				
				uniforms = {

					//tDisplacement: { type: "t", value: texture },
					directionalLightColor: { type: "v3", value: new THREE.Vector3(sun.color.r,sun.color.g,sun.color.b) },
					directionalLightDirection: { type: "v3", value: sun.position },
					uDisplacementScale: { type: "f", value: 1.0 },
					uDisplacementBias: { type: "f", value: 0.0 },

				};
				
				material = new THREE.ShaderMaterial( {
					uniforms: uniforms,
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent
					
				} );
				//console.log(material.uniforms);
				var sphere = new THREE.Mesh( new THREE.SphereGeometry( 1,50,50 ),  material );
				scene.add( sphere );
				
				
				
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
			}
			
			$(document).keydown(function(evt) {
				
				switch (evt.keyCode) 
				{
					case 87://w
						//mesh.rotation.x -= .02;
						camera.position.y += .05;
						break;
					case 65://a
						//mesh.rotation.y -= .02;
						camera.position.x -= .05;
						break;
					case 83://s
						//mesh.rotation.x += .02;
						camera.position.y -= .05;
						break;
					case 68://d
						//mesh.rotation.y += .02;
						camera.position.x += .05;
						break;
					case 73://d
						camera.position.z -= .07;
						break;
					case 79://d
						camera.position.z += .07;
						break;
					case 32://space
						anim = !anim;
						break;
					default:
						console.log(evt.keyCode);
						break;
				}
			});
			jQuery(document).ready(function($){
				$(document).bind('mousewheel', function(e){
					if(e.wheelDelta/120 > 0) {
						camera.position.z -= .07;
					}
					else{
						camera.position.z += .07;
					}
				});
			});
			
			function onWindowResize( event ) {

				//uniforms.resolution.value.x = window.innerWidth;
				//uniforms.resolution.value.y = window.innerHeight;

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

			}
			
			function animate() {
				if(anim){
					
				}
				requestAnimationFrame( animate );
				render();
			}
			function render() {
				renderer.render(scene, camera);
			}
		</script>
</body>
</html>
